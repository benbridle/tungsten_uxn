%CONSOLE.WRITE     { #18 }
%SYSTEM.RED        { #08 }
%SYSTEM.GREEN      { #0a }
%SYSTEM.BLUE       { #0c }
%SYSTEM.DEBUG      { #0e }
%SYSTEM.HALT       { #0f }
%SCREEN.VECTOR     { #20 }
%SCREEN.WIDTH      { #22 }
%SCREEN.HEIGHT     { #24 }
%SCREEN.X          { #28 }
%SCREEN.Y          { #2a }
%SCREEN.ADDR       { #2c }
%SCREEN.PIXEL      { #2e }
%SCREEN.SPRITE     { #2f }
%CONTROLLER.VECTOR { #80 }
%CONTROLLER.BUTTON { #82 }
%CONTROLLER.KEY    { #83 }
%MOUSE.VECTOR      { #90 }
%MOUSE.X           { #92 }
%MOUSE.Y           { #94 }
%MOUSE.STATE       { #95 }
%MOUSE.WHEEL       { #96 }

%MOD    { DIVk MUL SUB }
%MOD2   { DIV2k MUL2 SUB2 }
%DEC    { #01 SUB }
%DEC2   { #0001 SUB2 }
%CALL   { JSR2 }
%RETURN { JMP2r }
%GET_X  { SCREEN.X DEI2 }
%GET_Y  { SCREEN.Y DEI2 }
%SET_X  { SCREEN.X DEO2 }
%SET_Y  { SCREEN.Y DEO2 }
%PIXEL  { SCREEN.PIXEL DEO }
%HALF2  { #01 SFT2 }

%BREAKPOINT { #0101 SYSTEM.DEBUG DEO2 }

%>center_x { #00 STZ2 }
%!center_x { #00 LDZ2 }
%>center_y { #02 STZ2 }
%!center_y { #02 LDZ2 }

%>cursor_x { #04 STZ2 }
%!cursor_x { #04 LDZ2 }
%>cursor_y { #06 STZ2 }
%!cursor_y { #06 LDZ2 }

%>canvas_x { #08 STZ2 }
%!canvas_x { #08 LDZ2 }
%>canvas_y { #0a STZ2 }
%!canvas_y { #0a LDZ2 }

%>canvas_width  { #0c STZ2 }
%!canvas_width  { #0c LDZ2 }
%>canvas_height { #0e STZ2 }
%!canvas_height { #0e LDZ2 }


( ------------------------------------------------------------------------------- )
(                             M A I N   P R O G R A M                             )

|0100
  ;initialise_program CALL
  ( ;draw_splash_screen CALL )
  ;draw_workspace CALL
  ;draw_cursor CALL
BRK

@initialise_program ( -- )
  #f02b #e18a #a24d ;set_colours CALL
  SCREEN.WIDTH DEI2 #0023 SUB2 >canvas_width
  SCREEN.HEIGHT DEI2 #0023 SUB2 >canvas_height
  #0002 >cursor_x
  #0002 >cursor_y
  SCREEN.WIDTH DEI2 HALF2 >center_x
  SCREEN.HEIGHT DEI2 HALF2 >center_y
  !center_x !canvas_width HALF2 SUB2 >canvas_x
  !center_y !canvas_height HALF2 SUB2 >canvas_y
  ;on_controller CONTROLLER.VECTOR DEO2
  ;on_mouse MOUSE.VECTOR DEO2
  RETURN

@draw_splash_screen ( -- )
  !center_x #0040 SUB2 SET_X
  !center_y #0030 SUB2 SET_Y
  #01 #0080 #0060 ;draw_filled_rect CALL

  !center_x #0041 SUB2 SET_X
  !center_y #0031 SUB2 SET_Y
  #02 #0082 #0062 ;draw_rect CALL
  !center_x #0043 SUB2 SET_X
  !center_y #0033 SUB2 SET_Y
  #02 #0086 #0066 ;draw_rect CALL

  !center_x #0032 SUB2 SET_X
  !center_y #0008 ADD2 SET_Y
  #01 #02 ;draw_button CALL
  GET_Y #000c ADD2 SET_Y
  #01 #02 ;draw_button CALL
  RETURN

@draw_workspace ( -- )
  #02 ;fill_screen CALL
  ;draw_canvas CALL
  RETURN

@draw_canvas ( -- )
  !canvas_x SET_X !canvas_y SET_Y
  ;screen_buffer ;draw_1bit_buffer CALL
  RETURN

@draw_cursor ( -- )
  !cursor_x !cursor_y                        ( screen_x* screen_y* )
  ;cursor_sprite SCREEN.ADDR DEO2

  OVR2 #0004 SUB2 SET_X
  DUP2 #0004 SUB2 SET_Y
  #c5 SCREEN.SPRITE DEO
  OVR2 #0003 SUB2 SET_X
  DUP2 #0003 SUB2 SET_Y
  #f5 SCREEN.SPRITE DEO
  POP2 POP2 RETURN
  @cursor_sprite 1c1c 08c0 e0c0 0000 0008 0000 4000 0000  

@erase_cursor ( -- )
  !cursor_x !cursor_y                        ( x* y* )

  OVR2 #0004 SUB2 SET_X
  DUP2 #0004 SUB2 SET_Y
  #40 SCREEN.SPRITE DEO
  OVR2 #0003 SUB2 SET_X
  DUP2 #0003 SUB2 SET_Y
  #40 SCREEN.SPRITE DEO
  POP2 POP2 RETURN

@canvas_coord_to_screen ( canvas_x* canvas_y* -- screen_x* screen_y* )
  SWP2 !canvas_x ADD2
  SWP2 !canvas_y ADD2
  RETURN

@screen_coord_to_canvas ( screen_x* screen_y* -- canvas_x* canvas_y* )
  SWP2 !canvas_x SUB2                        ( screen_y* canvas_x* )
  SWP2 !canvas_y SUB2                        ( canvas_x* canvas_y* )
  RETURN

@canvas_coord_to_offset_and_mask ( canvas_x* canvas_y* -- offset* mask )
  !canvas_width MUL2 ADD2                    ( pixel_index* )
  DUP2 #0008 DIV2                            ( pixel_index* offset* )
  SWP2 #0008 MOD2 NIP                        ( offset* bit_id_lit_endian )
  #07 SWP SUB                                ( offset* bit_id_big_endian )
  #40 SFT #01 SWP SFT                        ( offset* mask )
  ( #40 SFT moves low nibble to high nibble, making the next SFT a left-shift )
  RETURN

@toggle_pixel ( canvas_x* canvas_y* -- )
  ;canvas_coord_to_offset_and_mask CALL    ( offset* mask )
  DUP SWP2                                 ( mask* offset* )
  ;screen_buffer ADD2                      ( mask* byte_address* )
  DUP2 LDA                                 ( mask* byte_address* byte )
  DUP ROT2                                 ( byte_address* byte* mask* )
  ROT POP2                                 ( byte_address* byte mask )
  EOR                                      ( byte_address* byte )
  ROT ROT STA
  RETURN

@set_pixel ( canvas_x* canvas_y* -- )
  OVR2 OVR2                                ( canvas_x* canvas_y* canvas_x* canvas_y* )
  ;canvas_coord_to_screen CALL             ( canvas_x* canvas_y* screen_x* screen_y* )
  SET_Y SET_X #01 PIXEL                    ( canvas_x* canvas_y* )
  ;canvas_coord_to_offset_and_mask CALL    ( offset* mask )
  DUP SWP2                                 ( mask* offset* )
  ;screen_buffer ADD2                      ( mask* byte_address* )
  DUP2 LDA                                 ( mask* byte_address* byte )
  DUP ROT2                                 ( byte_address* byte* mask* )
  ROT POP2                                 ( byte_address* byte mask )
  ORA                                      ( byte_address* byte )
  ROT ROT STA
  RETURN

@on_controller ( -- )  
  CONTROLLER.BUTTON DEI                      ( button )
  DUP #10 AND ,&up JCN 
  DUP #20 AND ,&down JCN
  DUP #40 AND ,&left JCN
  DUP #80 AND ,&right JCN
  DUP #01 AND ,&a JCN
  POP BRK

  &up POP
    ;erase_cursor CALL !cursor_y DEC2 >cursor_y ;draw_cursor CALL BRK
  &down POP
    ;erase_cursor CALL !cursor_y INC2 >cursor_y ;draw_cursor CALL BRK
  &left POP
    ;erase_cursor CALL !cursor_x DEC2 >cursor_x ;draw_cursor CALL BRK
  &right POP
    ;erase_cursor CALL !cursor_x INC2 >cursor_x ;draw_cursor CALL BRK
  &a POP
    !cursor_x !cursor_y                      ( screen_x* screen_y* )
    ;screen_coord_to_canvas CALL             ( canvas_x* canvas_y* )
    ;set_pixel CALL BRK

@on_mouse ( -- )
  !cursor_x MOUSE.X DEI2 NEQ2                ( is_x_different )
  !cursor_y MOUSE.Y DEI2 NEQ2                ( is_x_different is_y_different )
  ADD                                        ( is_mouse_same )
  ,&continue JCN BRK
  &continue

  MOUSE.X DEI2 MOUSE.Y DEI2                  ( screen_x* screen_y* )
  OVR2 OVR2
  POP2 POP2

  ;erase_cursor CALL
  >cursor_y >cursor_x
  ;draw_cursor CALL

  CONTROLLER.BUTTON DEI                      ( button )
  #01 AND ,&draw JCN
  BRK
  &draw
    !cursor_x !cursor_y ;screen_coord_to_canvas CALL ;set_pixel CALL
  BRK


( ------------------------------------------------------------------------------- )
(                         D R A W I N G   R O U T I N E S                         )

@set_colours ( red* green* blue* -- )
  SYSTEM.BLUE DEO2
  SYSTEM.GREEN DEO2
  SYSTEM.RED DEO2
  RETURN


@draw_rect ( colour width* height* -- )
  GET_Y DUP2 ,&start_y STR2                  ( colour width* height* y* )
  ADD2 DEC2 ,&target_y STR2                  ( colour width* )
  STH2 DUP ,&colour STR STH2r                ( colour width* )
  DUP2 ,&width STR2                          ( colour width* )
  ;draw_horizontal_line CALL                 ( // draw the top line )
  GET_Y INC2 SET_Y                           ( -- )
  ,&colour LDR                               ( colour )
  &loop
    DUP PIXEL                                ( // draw the left wall )
    GET_X ,&width LDR2 ADD2 DEC2 SET_X       ( colour  // move to right wall )
    DUP PIXEL                                ( // draw the right wall )
    GET_X ,&width LDR2 SUB2 INC2 SET_X       ( colour // move to left wall )
    GET_Y INC2 DUP2 SET_Y                    ( y* )
    [ LIT2 &target_y $2 ]                    ( y* target_y* )
    NEQ2 ,&loop JCN                          ( -- )
  ,&width LDR2 ;draw_horizontal_line CALL    ( // draw the bottom line )
  [ LIT2 &start_y $2 ] SET_Y
  RETURN
  &colour $1
  &width $2


@draw_filled_rect ( colour width* height* -- )
  GET_Y DUP2 ,&start_y STR2                  ( colour width* height* y* )
  ADD2 ,&target_y STR2                       ( colour width* )
  ,&width STR2 ,&colour STR                  ( -- )
  &loop
    [ LIT &colour $1 ]
    [ LIT2 &width $2 ]
    ;draw_horizontal_line CALL
    GET_Y INC2 DUP2 SET_Y                    ( y* )
    [ LIT2 &target_y $2 ]                    ( y* target_y* )
    NEQ2 ,&loop JCN                          ( -- )
  [ LIT2 &start_y $2 ] SET_Y
  RETURN


@draw_horizontal_line ( colour width* -- )
  SCREEN.X ,__draw_line/mode STR
  ,__draw_line JSR RETURN
@draw_vertical_line ( colour height* -- )
  SCREEN.Y ,__draw_line/mode STR
  ,__draw_line JSR RETURN
@__draw_line ( colour length* -- )
  ROT DUP SWP2                               ( colour* length* )
  [ ,&mode LDR ] DEI2 DUP2 ,&start STR2      ( colour* length* coord* )
  DUP2 ROT2 ADD2 SWP2                        ( colour* target* start* )
  &loop
    ROT2 DUP PIXEL ROT2 ROT2                 ( // draw a pixel )
    INC2 DUP2 [ ,&mode LDR ] DEO2            ( colour* target* coord* )
    NEQ2k ,&loop JCN                         ( colour* target* coord* )
  POP2 POP2 POP2                             ( -- )
  ,&start LDR2 [ ,&mode LDR ] DEO2           ( // reset coord to starting value )
  RETURN
  &mode $1
  &start $2


@draw_button ( bg_colour colour -- )
  #0064 #000a                                ( bg_colour colour width* height* )
  ;draw_filled_rect CALL                     ( bg_colour )
  GET_X #0063 ADD2 SET_X DUP PIXEL           ( bg_colour )
  GET_Y #0009 ADD2 SET_Y DUP PIXEL           ( bg_colour )
  GET_X #0063 SUB2 SET_X DUP PIXEL           ( bg_colour )
  GET_Y #0009 SUB2 SET_Y     PIXEL           ( -- )
  RETURN


@fill_screen ( colour -- )
  #0000 SET_X #0000 SET_Y                    ( colour )
  SCREEN.WIDTH DEI2 SCREEN.HEIGHT DEI2       ( colour width* height* )
  ;draw_filled_rect CALL                     ( -- )
  RETURN


@draw_1bit_buffer ( addr* )
  GET_X ,&start_x STR2
  GET_Y ,&start_y STR2
  #0000                                      ( addr* offset* )
  &next_byte
    ADD2k LDA #80                            ( addr* offset* byte mask )
  &draw_byte
    ANDk EQUk NIP PIXEL                      ( // draw pixel if bit is on )
    GET_X INC2 DUP2 SET_X                    ( addr* offset* byte mask x* )
    ,&start_x LDR2 SUB2                      ( addr* offset* byte mask x_offset* )
    !canvas_width LTH2                       ( addr* offset* byte mask is_line_incomplete )
    ,&draw_byte_cont JCN                     ( addr* offset* byte mask )
  &next_line
    GET_X !canvas_width SUB2 SET_X           ( addr* offset* byte mask )
    GET_Y INC2 DUP2 SET_Y                    ( addr* offset* byte mask y* )
    ,&start_y LDR2 SUB2                      ( addr* offset* byte mask y_offset* )
    !canvas_height LTH2                      ( addr* offset* byte mask is_buffer_incomplete )
    ,&draw_byte_cont JCN                     ( addr* offset* byte mask )
    POP2 POP2 POP2 RETURN                    ( -- )
  &draw_byte_cont
    #01 SFT                                  ( addr* offset* byte mask // set mask to next bit )
    DUP ,&draw_byte JCN                      ( addr* offset* byte mask // keep parsing bits )
    POP2 INC2                                ( addr* offset* )
    ,&next_byte JMP
  &start_x $2
  &start_y $2


@screen_buffer
  aaaa 0000 aaaa 0000
  aaaa 0000 aaaa 0000
  aaaa 0000 aaaa 0000
  aaaa 0000 aaaa 0000