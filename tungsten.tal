( ------------------------------------------------------------------------------- )
(                        M A C R O   D E F I N I T I O N S                        )

%CONSOLE.WRITE     { #18 }
%SYSTEM.RED        { #08 }
%SYSTEM.GREEN      { #0a }
%SYSTEM.BLUE       { #0c }
%SYSTEM.DEBUG      { #0e }
%SYSTEM.HALT       { #0f }
%SCREEN.VECTOR     { #20 }
%SCREEN.WIDTH      { #22 }
%SCREEN.HEIGHT     { #24 }
%SCREEN.X          { #28 }
%SCREEN.Y          { #2a }
%SCREEN.ADDR       { #2c }
%SCREEN.PIXEL      { #2e }
%SCREEN.SPRITE     { #2f }
%CONTROLLER.VECTOR { #80 }
%CONTROLLER.BUTTON { #82 }
%CONTROLLER.KEY    { #83 }
%MOUSE.VECTOR      { #90 }
%MOUSE.X           { #92 }
%MOUSE.Y           { #94 }
%MOUSE.STATE       { #95 }
%MOUSE.WHEEL       { #96 }

%!SCREEN.WIDTH      { SCREEN.WIDTH DEI2 }
%!SCREEN.HEIGHT     { SCREEN.HEIGHT DEI2 }
%!SCREEN.X          { SCREEN.X DEI2 }
%!SCREEN.Y          { SCREEN.Y DEI2 }
%!CONTROLLER.BUTTON { CONTROLLER.BUTTON DEI }
%!CONTROLLER.KEY    { CONTROLLER.KEY DEI }
%!MOUSE.X           { MOUSE.X DEI2 }
%!MOUSE.Y           { MOUSE.Y DEI2 }
%!MOUSE.STATE       { MOUSE.STATE DEI }
%!MOUSE.WHEEL       { MOUSE.WHEEL DEI }

%>SYSTEM.RED        { SYSTEM.RED DEO2 }
%>SYSTEM.GREEN      { SYSTEM.GREEN DEO2 }
%>SYSTEM.BLUE       { SYSTEM.BLUE DEO2 }
%>CONSOLE.WRITE     { CONSOLE.WRITE DEO }
%>SCREEN.VECTOR     { SCREEN.VECTOR DEO2 }
%>SCREEN.X          { SCREEN.X DEO2 }
%>SCREEN.Y          { SCREEN.Y DEO2 }
%>SCREEN.ADDR       { SCREEN.ADDR DEO2 }
%>SCREEN.PIXEL      { SCREEN.PIXEL DEO }
%>SCREEN.SPRITE     { SCREEN.SPRITE DEO }
%>CONTROLLER.VECTOR { CONTROLLER.VECTOR DEO2 }
%>MOUSE.VECTOR      { MOUSE.VECTOR DEO2 }

%MOD      { DIVk MUL SUB }
%MOD2     { DIV2k MUL2 SUB2 }
%DEC      { #01 SUB }
%DEC2     { #0001 SUB2 }
%CALL     { JSR2 }
%RETURN   { JMP2r }
%HALF2    { #01 SFT2 }
%DOUBLE2  { #10 SFT2 }
%ISNEG2   { #7fff GTH2 }
%ISPOS2   { #8000 LTH2 }
%NOT      { #00 EQU }
%NEG2     { #0000 SWP2 SUB2 }
%ABS2     { DUP2 ISPOS2 #05 JCN NEG2 }

%INC_X    { !SCREEN.X INC2 >SCREEN.X }
%INC_Y    { !SCREEN.Y INC2 >SCREEN.Y }
%DEC_X    { !SCREEN.X DEC2 >SCREEN.X }
%DEC_Y    { !SCREEN.Y DEC2 >SCREEN.Y }
%ADD_X    { !SCREEN.X ADD2 >SCREEN.X }
%ADD_Y    { !SCREEN.Y ADD2 >SCREEN.Y }
%SUB_X    { !SCREEN.X SWP2 SUB2 >SCREEN.X }
%SUB_Y    { !SCREEN.Y SWP2 SUB2 >SCREEN.Y }

%BREAK_IF_NOT  { #01 JCN BRK }
%BREAKPOINT  { #0101 SYSTEM.DEBUG DEO2 }
%DEBUG { #00 ;fill_screen CALL BREAKPOINT }
%HALT  { #01 SYSTEM.HALT DEO }

( ------------------------------------------------------------------------------- )
(                         G L O B A L   V A R I A B L E S                         )

%>center_x  { #00 STZ2 }
%!center_x  { #00 LDZ2 }
%>center_y  { #02 STZ2 }
%!center_y  { #02 LDZ2 }

%>cursor_x  { #04 STZ2 }
%!cursor_x  { #04 LDZ2 }
%>cursor_y  { #06 STZ2 }
%!cursor_y  { #06 LDZ2 }

%>canvas_x  { #08 STZ2 }
%!canvas_x  { #08 LDZ2 }
%>canvas_y  { #0a STZ2 }
%!canvas_y  { #0a LDZ2 }

%>canvas_width  { #0c STZ2 }
%!canvas_width  { #0c LDZ2 }
%>canvas_height { #0e STZ2 }
%!canvas_height { #0e LDZ2 }

%>button_pressed  { #10 STZ }
%!button_pressed  { #10 LDZ }
%>button_released { #11 STZ }
%!button_released { #11 LDZ }
%>button_held     { #12 STZ }
%!button_held     { #12 LDZ }

( ------------------------------------------------------------------------------- )
(                             M A I N   P R O G R A M                             )

|0100
  !SCREEN.WIDTH HALF2 >center_x
  !SCREEN.HEIGHT HALF2 >center_y
  #f02b #e18a #a24d ;set_colours CALL

  ;on_controller >CONTROLLER.VECTOR
  ;on_mouse >MOUSE.VECTOR
  ;on_screen >SCREEN.VECTOR

  ;draw_splash_screen CALL
BRK


@draw_splash_screen ( -- )
  #00 ;fill_screen CALL
  !center_x #0040 SUB2 >SCREEN.X
  !center_y #0030 SUB2 >SCREEN.Y
  #01 #0080 #0060 ;draw_filled_rect CALL
  DEC_X DEC_Y
  #02 #0082 #0062 ;draw_rect CALL
  #0002 DUP2 SUB_X SUB_Y
  #02 #0086 #0066 ;draw_rect CALL

  ( Draw buttons )
  !center_x #0032 SUB2 >SCREEN.X
  !center_y #0008 ADD2 >SCREEN.Y
  #0c #0064 ;&button_1_text ;draw_button CALL
  !SCREEN.Y #000c ADD2 >SCREEN.Y
  #08 #0064 ;&button_2_text ;draw_button CALL
  RETURN
  &button_1_text "Create 20 "image 00
  &button_2_text "Load 20 "image 00

@draw_create_image_screen ( -- )
  #00 ;fill_screen CALL
  !center_x #0040 SUB2 >SCREEN.X
  !center_y #0030 SUB2 >SCREEN.Y
  #01 #0080 #0060 ;draw_filled_rect CALL
  DEC_X DEC_Y
  #02 #0082 #0062 ;draw_rect CALL
  #0002 DUP2 SUB_X SUB_Y
  #02 #0086 #0066 ;draw_rect CALL

  ( Back button )
  !center_x #003c SUB2 >SCREEN.X
  !center_y #002c SUB2 >SCREEN.Y
  #08 ;&back_sprite ;draw_icon_button CALL

  ( "Create image" title )
  !center_x #0023 SUB2 >SCREEN.X
  !center_y #002a SUB2 >SCREEN.Y
  #04 ;&title_text ;draw_text CALL

  ( Colour mode )
  !center_x #0032 SUB2 >SCREEN.X
  !center_y #0018 SUB2 >SCREEN.Y
  #02 #08 #0064 ;&1_bit_text ;&2_bit_text #00 ;draw_toggle CALL

  ( Width/height labels )
  !center_x #0032 SUB2 >SCREEN.X
  !center_y #0006 SUB2 >SCREEN.Y
  #04 ;&width_text ;draw_text CALL
  #000c ADD_Y
  #04 ;&height_text ;draw_text CALL

  ( Width/height inputs )
  !center_x #0003 ADD2 >SCREEN.X
  !center_y #0008 SUB2 >SCREEN.Y
  #0c #002f #0140 ;draw_numeric_input CALL
  #000c ADD_Y
  #08 #002f #00f0 ;draw_inactive_numeric_input CALL

  ( CONFIRM )
  !center_x #0032 SUB2 >SCREEN.X
  !center_y #001b ADD2 >SCREEN.Y
  #02 #0064 ;&confirm_text ;draw_button CALL

  RETURN
  &title_text "CREATE 20 "IMAGE 00
  &confirm_text "CONFIRM 00
  &back_sprite 1830 60ff ff60 3018
  &width_text "Width: 00
  &height_text "Height: 00
  &width_value "320 00
  &height_value "240 00
  &1_bit_text "1-bit 00
  &2_bit_text "2-bit 00


@draw_workspace ( -- )
  #02 ;fill_screen CALL
  ;draw_canvas CALL
  RETURN


@draw_canvas ( -- )
  !canvas_x >SCREEN.X !canvas_y >SCREEN.Y
  ;screen_buffer ;draw_1bit_buffer CALL
  RETURN


@draw_cursor ( -- )
  !cursor_x !cursor_y                        ( screen_x* screen_y* )
  ;cursor_sprite SCREEN.ADDR DEO2

  OVR2 #0004 SUB2 >SCREEN.X
  DUP2 #0004 SUB2 >SCREEN.Y
  #c5 SCREEN.SPRITE DEO
  OVR2 #0003 SUB2 >SCREEN.X
  DUP2 #0003 SUB2 >SCREEN.Y
  #f5 SCREEN.SPRITE DEO
  POP2 POP2 RETURN
  @cursor_sprite 1c1c 08c0 e0c0 0000 0008 0000 4000 0000  


@erase_cursor ( -- )
  !cursor_x !cursor_y                        ( x* y* )

  OVR2 #0004 SUB2 >SCREEN.X
  DUP2 #0004 SUB2 >SCREEN.Y
  #40 SCREEN.SPRITE DEO
  OVR2 #0003 SUB2 >SCREEN.X
  DUP2 #0003 SUB2 >SCREEN.Y
  #40 SCREEN.SPRITE DEO
  POP2 POP2 RETURN


@canvas_coord_to_screen ( canvas_x* canvas_y* -- screen_x* screen_y* )
  SWP2 !canvas_x ADD2
  SWP2 !canvas_y ADD2
  RETURN


@screen_coord_to_canvas ( screen_x* screen_y* -- canvas_x* canvas_y* )
  SWP2 !canvas_x SUB2                        ( screen_y* canvas_x* )
  SWP2 !canvas_y SUB2                        ( canvas_x* canvas_y* )
  RETURN


@canvas_coord_to_offset_and_mask ( canvas_x* canvas_y* -- offset* mask )
  !canvas_width MUL2 ADD2                    ( pixel_index* )
  DUP2 #0008 DIV2                            ( pixel_index* offset* )
  SWP2 #0008 MOD2 NIP                        ( offset* bit_id_lit_endian )
  #07 SWP SUB                                ( offset* bit_id_big_endian )
  #40 SFT #01 SWP SFT                        ( offset* mask )
  ( #40 SFT moves low nibble to high nibble, making the next SFT a left-shift )
  RETURN


@toggle_pixel ( canvas_x* canvas_y* -- )
  ;canvas_coord_to_offset_and_mask CALL      ( offset* mask )
  DUP SWP2                                   ( mask* offset* )
  ;screen_buffer ADD2                        ( mask* byte_address* )
  DUP2 LDA                                   ( mask* byte_address* byte )
  DUP ROT2                                   ( byte_address* byte* mask* )
  ROT POP2                                   ( byte_address* byte mask )
  EOR                                        ( byte_address* byte )
  ROT ROT STA
  RETURN


@set_pixel ( canvas_x* canvas_y* -- )
  OVR2 OVR2                                  ( canvas_x* canvas_y* canvas_x* canvas_y* )
  ;canvas_coord_to_screen CALL               ( canvas_x* canvas_y* screen_x* screen_y* )
  >SCREEN.Y >SCREEN.X #01 >SCREEN.PIXEL      ( canvas_x* canvas_y* )
  ;canvas_coord_to_offset_and_mask CALL      ( offset* mask )
  DUP SWP2                                   ( mask* offset* )
  ;screen_buffer ADD2                        ( mask* byte_address* )
  DUP2 LDA                                   ( mask* byte_address* byte )
  DUP ROT2                                   ( byte_address* byte* mask* )
  ROT POP2                                   ( byte_address* byte mask )
  ORA                                        ( byte_address* byte )
  ROT ROT STA
  RETURN


@update_button_states ( -- )
  !CONTROLLER.BUTTON DUP DUP2                ( held held held held )
  !button_held                               ( held held held held prev_held )
  EOR AND                                    ( held held leading_edge )
  DUP ROT EOR                                ( held leading_edge falling_edge )
  >button_released 
  >button_pressed 
  >button_held
  RETURN


@on_controller ( -- )  
  ;update_button_states CALL
  !button_pressed #10 AND ,&up JCN 
  !button_pressed #20 AND ,&down JCN
  !button_pressed #40 AND ,&left JCN
  !button_pressed #80 AND ,&right JCN
  !button_pressed #01 AND ,&a JCN
  BRK

  &up
    ;erase_cursor CALL !cursor_y DEC2 >cursor_y ;draw_cursor CALL BRK
  &down
    ;erase_cursor CALL !cursor_y INC2 >cursor_y ;draw_cursor CALL BRK
  &left
    ;erase_cursor CALL !cursor_x DEC2 >cursor_x ;draw_cursor CALL BRK
  &right
    ;erase_cursor CALL !cursor_x INC2 >cursor_x ;draw_cursor CALL BRK
  &a
    !cursor_x !cursor_y                      ( screen_x* screen_y* )
    ;screen_coord_to_canvas CALL             ( canvas_x* canvas_y* )
    ;set_pixel CALL BRK


@on_mouse ( -- )
  !cursor_x !MOUSE.X NEQ2                    ( is_x_different )
  !cursor_y !MOUSE.Y NEQ2                    ( is_x_different is_y_different )
  ADD                                        ( is_mouse_different )
  BREAK_IF_NOT

  ;erase_cursor CALL                         ( -- )
  !MOUSE.X >cursor_x
  !MOUSE.Y >cursor_y
  ;draw_cursor CALL

  CONTROLLER.BUTTON DEI                      ( button )
  #01 AND ,&draw JCN
  BRK
  &draw
    !cursor_x !cursor_y ;screen_coord_to_canvas CALL ;set_pixel CALL
  BRK


@on_screen ( -- )
  ;&counter LDA2k INC2 DUP2 ROT2 STA2                 ( counter* // increment the counter )
  #03 SFT2 #0004 MOD2                                 ( 4-step-counter* )
  #0006 MUL2                                          ( scheme_offset* )
  ;colour_scheme_1 ADD2                               ( scheme_addr* )
  ;load_colours CALL                                  ( -- )
  BRK
  &counter $2

( ------------------------------------------------------------------------------- )
(                    C O N V E R S I O N   P R O C E D U R E S                    )

@convert_short_to_decimal_string ( value* -- text_addr* )
  ;&text_addr                                 ( value* digit_addr* )
  OVR2 #000a LTH2 ,&parse JCN INC2           ( // jump if number has 1 digit  )
  OVR2 #0064 LTH2 ,&parse JCN INC2           ( // jump if number has 2 digits )
  OVR2 #03e8 LTH2 ,&parse JCN INC2           ( // jump if number has 3 digits )
  OVR2 #2710 LTH2 ,&parse JCN INC2           ( // jump if number has 4 digits )

  &parse
    DUP2 INC2 #00 ROT ROT                    ( value* digit_addr* 00 null_addr* )
    STA SWP2                                 ( digit_addr* value* )
  &loop
    DUP2 #000a MOD2                          ( digit_addr* value* remainder* )
    SWP2 #000a DIV2 SWP2                     ( digit_addr* value* remainder* )
    NIP #30 ADD DUP                          ( digit_addr* value* ascii* )
    ROT2 SWP2                                ( value* digit_addr* ascii* )
    OVR2 ROT POP                             ( value* digit_addr* ascii digit_addr* )
    STA DEC2 SWP2                            ( digit_addr* value* )
    OVR2 INC2 ;&text_addr NEQ2 ,&loop JCN
  POP2 INC2 RETURN                           ( text_addr* )
  &text_addr $5 00



( ------------------------------------------------------------------------------- )
(                  U S E R   I N T E R F A C E   E L E M E N T S                  )

@draw_button ( colour width* text_addr* -- )
  ,&text_addr STR2                           ( sprite_colour width* // store text_addr )
  STH2 DUP ,&sprite_colour STR #02 SFT STH2r ( pixel_colour width* // store colour )
  DUP2 ,&button_width STR2                   ( colour width* // store button width )
  #000b ;draw_capsule CALL                   ( -- )
  !SCREEN.Y #0002 ADD2 >SCREEN.Y             ( // move down to top of text )
  !SCREEN.X ,&start_x STR2                   ( -- )

  [ LIT &sprite_colour $1 ]
  [ LIT2 &text_addr $2 ]
  [ LIT2 &button_width $2 ]                  ( sprite_colour text_addr* button_width* )

  OVR2 ;get_text_width CALL                  ( sprite_colour text_addr* button_width* text_width* )
  SUB2 HALF2                                 ( sprite_colour text_addr* text_x_offset* )
  !SCREEN.X ADD2 >SCREEN.X                   ( sprite_colour text_addr* )
  ;draw_text CALL

  !SCREEN.Y #0002 SUB2 >SCREEN.Y
  [ LIT2 &start_x $2 ]  >SCREEN.X
  RETURN


@draw_icon_button ( colour sprite_addr* -- )
  >SCREEN.ADDR
  DUP #02 SFT #000a #000a ;draw_capsule CALL
  INC_X INC_Y
  >SCREEN.SPRITE
  DEC_X DEC_Y
  RETURN


@draw_toggle ( bg_colour fg_colour width* text_addr_1* text_addr_2* value -- )
  !SCREEN.X ,&start_x STR2                   ( ... )
  !SCREEN.Y ,&start_y STR2                   ( ... )
  STH                                        ( ... | value )
  ,&text_addr_2 STR2 ,&text_addr_1 STR2      ( bg fg width* | value )
  DUP2 #0004 SUB2 #01 SFT2                   ( bg fg width* half_width* | value )
  ,&half_width STR2                          ( bg fg width* | value )
  DUP2 #0001 AND2 ,&spacer STR2              ( // more padding for odd widths )
  ,&width STR2                               ( bg fg | value )
  OVR STHr                                   ( bg fg bg value )
  JMP SWP                                    ( bg fg bg // swap if value is 00 )
  ,&left_colour STR ,&right_colour STR       ( bg )

  #02 SFT [ LIT2 &width $2 ]                 ( pixel_colour* width* )
  #000d ;draw_capsule CALL                   ( // draw the full background )
  INC_X INC_Y
  [ LIT &left_colour $1 ] ,&half_width LDR2  
  [ LIT2 &text_addr_1 $2 ] ;draw_button CALL
  ,&half_width LDR2 #0002 ADD2 [ LIT2 &spacer $2 ] ADD2 ADD_X
  [ LIT &right_colour $1 ] ,&half_width LDR2 
  [ LIT2 &text_addr_2 $2 ] ;draw_button CALL
  [ LIT2 &start_x $2 ] [ LIT2 &start_y $2 ]
  >SCREEN.Y >SCREEN.X
  RETURN
  &half_width $2


@draw_numeric_input ( colour width* number* -- )
  !SCREEN.X ,&start_x STR2
  STH2 STH2                                  ( colour | width* number* )
  DUP ,&colour STR STH2r                     ( colour width* | number* )
  DUP2 ,&width STR2 STH2r                    ( colour width* number* )
  ;convert_short_to_decimal_string CALL      ( colour width* text_addr* )
  ;draw_button CALL                          ( -- )
  ;&arrow_sprite >SCREEN.ADDR
  #0002 ADD_Y #0002 ADD_X                    ( // position cursor for left-arrow )
  ,&colour LDR >SCREEN.SPRITE                ( // draw left arrow )
  ,&width LDR2 #000c SUB2 ADD_X              ( // position cursor for right-arrow )
  ,&colour LDR #10 ORA >SCREEN.SPRITE        ( // #10 is horizontal-flip )
  [ LIT2 &start_x $2 ] >SCREEN.X
  #0002 SUB_Y
  RETURN
  &colour $1  &width $2
  &arrow_sprite 1030 70f0 7030 1000


@draw_inactive_numeric_input ( colour width* number* -- )
  ;convert_short_to_decimal_string CALL      ( colour width* text_addr* )
  ;draw_button CALL                          ( -- )
  RETURN

( ------------------------------------------------------------------------------- )
(                         D R A W I N G   R O U T I N E S                         )

@set_colours ( red* green* blue* -- )
  SYSTEM.BLUE DEO2
  SYSTEM.GREEN DEO2
  SYSTEM.RED DEO2
  RETURN


@load_colours ( colour_scheme_addr* -- )
  LDA2k SWP2 INC2 INC2
  LDA2k SWP2 INC2 INC2
  LDA2 ;set_colours CALL
  RETURN


@fill_screen ( colour -- )
  #0000 >SCREEN.X #0000 >SCREEN.Y            ( colour )
  SCREEN.WIDTH DEI2 SCREEN.HEIGHT DEI2       ( colour width* height* )
  ;draw_filled_rect CALL                     ( -- )
  RETURN


@draw_line ( colour x0* y0* x1* y1* -- )
  ,&y1 STR2 ,&x1 STR2                        ( colour x0* y0* )
  DUP2 ,&y0 STR2 >SCREEN.Y                   ( colour x0* )
  DUP2 ,&x0 STR2 >SCREEN.X                   ( colour )
  ,&colour STR                               ( -- )
  ,&x1 LDR2 [ LIT2 &x0 $2 ] SUB2             ( dx* )
  [ LIT2 &y1 $2 ]  [ LIT2 &y0 $2 ]  SUB2     ( dx* dy* )
  DUP2 ISPOS2                                ( dx* dy* is_dy_zero_or_greater )
  ,&dy_zero_or_greater JCN                   ( dx* dy* )

  &dy_is_negative
    #ffff ,&yi STR2                          ( dx* dy* )
    NEG2                                     ( dx* -dy* )
    ,&start_cont JMP
  &dy_zero_or_greater
    #0001 ,&yi STR2                          ( dx* dy* )  
  &start_cont
    OVR2 ,&dx STR2 DUP2 ,&dy STR2            ( // store dx and dy )
    DOUBLE2 SWP2 SUB2                        ( D* )  
    ,&loop JMP
      &x1 $2  &dx $2  &dy $2

  &loop
    [ LIT &colour $1 ]  >SCREEN.PIXEL        ( D* )
    DUP2 DEC2 ISNEG2                         ( D* is_d_less_or_equal_zero )
    ,&d_less_or_equal_zero JCN               ( D* )
  &d_greater_than_zero
    !SCREEN.Y  [ LIT2 &yi 0001 ]             ( D* y* yi* )
    ADD2 >SCREEN.Y                           ( D*  // increment y )
    ,&dy LDR2 ,&dx LDR2 SUB2                 ( D* dy-dx* )
    DOUBLE2 ADD2                             ( D*  // D+=2*(dy-dx) )
    ,&increment_x_and_check_if_done JMP      ( D* )
  &d_less_or_equal_zero
    ,&dy LDR2 DOUBLE2 ADD2                   ( D* // D+=2*dy )
  &increment_x_and_check_if_done
    !SCREEN.X DUP2 INC2                      ( D* x* x+1* )
    >SCREEN.X ,&x1 LDR2 LTH2                 ( D* is_line_complete // increment x )
    ,&loop JCN                               ( D* )
  POP2 RETURN


@draw_rect ( colour width* height* -- )
  !SCREEN.Y DUP2 ,&start_y STR2              ( colour width* height* y* )
  ADD2 DEC2 ,&target_y STR2                  ( colour width* )
  STH2 DUP ,&colour STR STH2r                ( colour width* )
  DUP2 ,&width STR2                          ( colour width* )
  ;draw_horizontal_line CALL                 ( // draw the top line )
  INC_Y ,&colour LDR                         ( colour // move to next line )
  &loop
    DUP >SCREEN.PIXEL                        ( // draw the left wall )
    !SCREEN.X ,&width LDR2 ADD2 DEC2 >SCREEN.X   ( colour  // move to right wall )
    DUP >SCREEN.PIXEL                        ( // draw the right wall )
    !SCREEN.X ,&width LDR2 SUB2 INC2 >SCREEN.X   ( colour // move to left wall )
    !SCREEN.Y INC2 DUP2 >SCREEN.Y            ( y* )
    [ LIT2 &target_y $2 ]                    ( y* target_y* )
    NEQ2 ,&loop JCN                          ( -- )
  ,&width LDR2 ;draw_horizontal_line CALL    ( // draw the bottom line )
  [ LIT2 &start_y $2 ] >SCREEN.Y
  RETURN
  &colour $1
  &width $2


@draw_filled_rect ( colour width* height* -- )
  !SCREEN.Y DUP2 ,&start_y STR2              ( colour width* height* y* )
  ADD2 ,&target_y STR2                       ( colour width* )
  ,&width STR2 ,&colour STR                  ( -- )
  &loop
    [ LIT &colour $1 ]
    [ LIT2 &width $2 ]
    ;draw_horizontal_line CALL
    !SCREEN.Y INC2 DUP2 >SCREEN.Y            ( y* )
    [ LIT2 &target_y $2 ]                    ( y* target_y* )
    NEQ2 ,&loop JCN                          ( -- )
  [ LIT2 &start_y $2 ] >SCREEN.Y
  RETURN


@draw_horizontal_line ( colour width* -- )
  SCREEN.X ,__draw_line/mode STR
  ,__draw_line JSR RETURN
@draw_vertical_line ( colour height* -- )
  SCREEN.Y ,__draw_line/mode STR
  ,__draw_line JSR RETURN
@__draw_line ( colour length* -- )
  ROT DUP SWP2                               ( colour* length* )
  [ ,&mode LDR ] DEI2 DUP2 ,&start STR2      ( colour* length* coord* )
  DUP2 ROT2 ADD2 SWP2                        ( colour* target* start* )
  &loop
    ROT2 DUP >SCREEN.PIXEL ROT2 ROT2         ( // draw a pixel )
    INC2 DUP2 [ ,&mode LDR ] DEO2            ( colour* target* coord* )
    NEQ2k ,&loop JCN                         ( colour* target* coord* )
  POP2 POP2 POP2                             ( -- )
  ,&start LDR2 [ ,&mode LDR ] DEO2           ( // reset coord to starting value )
  RETURN
  &mode $1
  &start $2


@draw_text ( colour text_addr* -- )
  ROT ,&colour STR                           ( text_addr* )
  !SCREEN.X ,&start_x STR2                   ( text_addr* )
  &loop
    DUP2 LDA                                 ( text_addr* ascii )
    DUP ,&render JCN                         ( text_addr* ascii )
  &end
    POP POP2                                 ( -- )
    [ LIT2 &start_x $2 ] >SCREEN.X           ( // move x back to start )
    RETURN
  &render
    #20 SUB #00 SWP                          ( text_addr* char_code* )
    DUP2 #30 SFT2                            ( text_addr* char_code* char_offset* )
    ;acorn_font/characters ADD2              ( text_addr* char_code* char_addr* )
    >SCREEN.ADDR                             ( text_addr* char_code* )
    [ LIT &colour $1 ]  >SCREEN.SPRITE       ( text_addr* char_code* )
    ;acorn_font/width ADD2                   ( text_addr* width_addr* )
    LDA #00 SWP                              ( text_addr* char_width* )
    !SCREEN.X ADD2 >SCREEN.X                 ( text_addr* // move x along )
    INC2                                     ( text_addr* )
    ,&loop JMP


@get_text_width ( text_addr* -- width* )
  #0000                                      ( text_addr* width* )
  &loop
    OVR2 LDA                                 ( text_addr* width* ascii )
    DUP ,&cont JCN                           ( text_addr* width* ascii )
  &end
    POP NIP2 RETURN
  &cont
    #20 SUB #00 SWP                          ( text_addr* width* char_code* )
    ;acorn_font/width ADD2                   ( text_addr* width* width_addr* )
    LDA #00 SWP                              ( text_addr* width* char_width* )
    ADD2                                     ( text_addr* width* )
    SWP2 INC2 SWP2                           ( text_addr* width* )
    ,&loop JMP


@draw_capsule ( colour width* height* -- )
  !SCREEN.Y ,&start_y STR2
  NIP #02 SUB ROT ROT                        ( colour counter width* )
  DUP2 ,&width STR2                          ( colour counter width* )
  #0002 SUB2 ,&short_width STR2              ( colour counter )
  &loop
    INC_Y                                    ( colour counter // move to next line )
    SWP DUP [ LIT2 &width $2 ]               ( counter colour colour width* )
    ;draw_horizontal_line CALL SWP           ( colour counter )
    DEC DUP ,&loop JCN                       ( colour counter )
  POP INC_X INC_Y                            ( colour // move to bottom line )
  DUP [ LIT2 &short_width $2 ]               ( colour colour short_width* )
  OVR2 OVR2 ROT POP                          ( colour colour short_width* colour short_width* )
  ;draw_horizontal_line CALL                 ( colour colour short_width* // draw bottom line )
  [ LIT2 &start_y $2 ]  >SCREEN.Y            ( colour colour short_width* // move to top line )
  ;draw_horizontal_line CALL                 ( colour // draw top line )
  POP DEC_X                                  ( -- // return to start )
  RETURN


@draw_1bit_buffer ( addr* )
  !SCREEN.X ,&start_x STR2
  !SCREEN.Y ,&start_y STR2
  #0000                                      ( addr* offset* )
  &next_byte
    ADD2k LDA #80                            ( addr* offset* byte mask )
  &draw_byte
    ANDk EQUk NIP >SCREEN.PIXEL              ( // draw pixel if bit is on )
    !SCREEN.X INC2 DUP2 >SCREEN.X            ( addr* offset* byte mask x* )
    ,&start_x LDR2 SUB2                      ( addr* offset* byte mask x_offset* )
    !canvas_width LTH2                       ( addr* offset* byte mask is_line_incomplete )
    ,&draw_byte_cont JCN                     ( addr* offset* byte mask )
  &next_line
    !SCREEN.X !canvas_width SUB2 >SCREEN.X   ( addr* offset* byte mask )
    !SCREEN.Y INC2 DUP2 >SCREEN.Y            ( addr* offset* byte mask y* )
    ,&start_y LDR2 SUB2                      ( addr* offset* byte mask y_offset* )
    !canvas_height LTH2                      ( addr* offset* byte mask is_buffer_incomplete )
    ,&draw_byte_cont JCN                     ( addr* offset* byte mask )
    POP2 POP2 POP2 RETURN                    ( -- )
  &draw_byte_cont
    HALF2                                    ( addr* offset* byte mask )
    DUP ,&draw_byte JCN                      ( addr* offset* byte mask )
    POP2 INC2                                ( addr* offset* )
    ,&next_byte JMP
  &start_x $2
  &start_y $2

( ------------------------------------------------------------------------------- )
(                                     D A T A                                     )

@colour_scheme_1
  f022 e188 a244
  f023 e188 a245
  f025 e189 a246
  f023 e188 a245


@acorn_font
  &width
0405 0408 0807 0802
0505 0807 0405 0307
0705 0707 0707 0707
0707 0304 0605 0607
0707 0707 0706 0607
0705 0707 0608 0807
0707 0707 0707 0708
0707 0705 0705 0706
0407 0707 0707 0607
0705 0507 0508 0707
0708 0707 0607 0708
0707 0705 0205 0808 
  &characters
0000 0000 0000 0000  (   )
60f0 f060 6000 6000  ( ! )
a0a0 0000 0000 0000  ( " )
6c6c fe6c fe6c 6c00  ( # )
107c e07c 0e7c 1000  ( $ )
cccc 1830 60cc cc00  ( % )
70d8 d870 dacc 7600  ( & )
8080 0000 0000 0000  ( ' )
3060 c0c0 c060 3000  ( ( )
c060 3030 3060 c000  ( ) )
6c38 fe38 6c00 0000  ( * )
0030 30fc 3030 0000  ( + )
0000 0000 0060 60c0  ( , )
0000 00f0 0000 0000  ( - )
0000 0000 00c0 c000  ( . )
0c18 1830 3060 60c0  ( / )
78cc dcfc eccc 7800  ( 0 )
60e0 6060 6060 f000  ( 1 )
78cc 0c38 60c4 fc00  ( 2 )
78cc 0c38 0ccc 7800  ( 3 )
1838 78d8 fc18 1800  ( 4 )
fcc0 f81c 0ccc 7800  ( 5 )
3860 c0f8 cccc 7800  ( 6 )
fc0c 1830 6060 6000  ( 7 )
78cc cc78 cccc 7800  ( 8 )
78cc cc7c 0c18 7000  ( 9 )
00c0 c000 00c0 c000  ( : )
0060 6000 0060 60c0  ( ; )
1830 60c0 6030 1800  ( < )
0000 f000 f000 0000  ( = )
c060 3018 3060 c000  ( > )
78cc 1830 3000 3000  ( ? )
78cc dcd4 dcc0 7800  ( @ )
78cc cccc fccc cc00  ( A )
f8cc ccf8 cccc f800  ( B )
78cc c0c0 c0cc 7800  ( C )
f8cc cccc cccc f800  ( D )
f8c0 c0f0 c0c0 f800  ( E )
f8c0 c0f0 c0c0 c000  ( F )
78cc c0dc cccc 7800  ( G )
cccc ccfc cccc cc00  ( H )
f060 6060 6060 f000  ( I )
7c18 1818 18d8 7000  ( J )
cccc d8f0 d8cc cc00  ( K )
c0c0 c0c0 c0c0 f800  ( L )
c6ee fed6 d6c6 c600  ( M )
c6e6 f6de cec6 c600  ( N )
78cc cccc cccc 7800  ( O )
f8cc cccc f8c0 c000  ( P )
78cc cccc d4d8 6c00  ( Q )
f8cc ccf8 cccc cc00  ( R )
78cc c078 0ccc 7800  ( S )
fc30 3030 3030 3000  ( T )
cccc cccc cccc 7800  ( U )
cccc cccc cc78 3000  ( V )
c6c6 c6d6 d6fe 6c00  ( W )
cccc 7830 78cc cc00  ( X )
cccc cc78 3030 3000  ( Y )
fc1c 3830 70e0 fc00  ( Z )
f0c0 c0c0 c0c0 f000  ( [ )
c060 6030 3018 180c  ( \ )
f030 3030 3030 f000  ( ] )
3071 cc84 0000 0000  ( ^ )
0000 0000 0000 f800  ( _ )
c060 0000 0000 0000  ( ` )
0000 780c 7ccc 7c00  ( a )
c0c0 f8cc cccc f800  ( b )
0000 78cc c0cc 7800  ( c )
0c0c 7ccc cccc 7c00  ( d )
0000 78cc fcc0 7800  ( e )
3860 60f8 6060 6000  ( f )
0000 7ccc cc7c 0c78  ( g )
c0c0 f8cc cccc cc00  ( h )
6000 e060 6060 f000  ( i )
3000 7030 3030 30e0  ( j )
c0c0 ccd8 f0d8 cc00  ( k )
e060 6060 6060 f000  ( l )
0000 6cfe d6d6 c600  ( m )
0000 f8cc cccc cc00  ( n )
0000 78cc cccc 7800  ( o )
0000 f8cc ccf8 c0c0  ( p )
0000 7ccc cc7c 0c0e  ( q )
0000 d8ec c0c0 c000  ( r )
0000 7ce0 781c f800  ( s )
6060 f860 6060 3800  ( t )
0000 cccc cccc 7800  ( u )
0000 cccc cc78 3000  ( v )
0000 c6d6 d6fe 6c00  ( w )
0000 cc78 3078 cc00  ( x )
0000 cccc cc7c 0c78  ( y )
0000 fc18 3060 fc00  ( z )
3060 60c0 6060 3000  ( { )
8080 8080 8080 8000  ( | )
c060 6030 6060 c000  ( } )
0000 62d6 8c00 0000  ( ~ )
2514 2189 4125 1426  (   )


@screen_buffer
(
  This label needs to be at the end of the
  program, to ensure that there is enough
  space for the largest possible canvas.
)